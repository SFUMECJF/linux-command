


贝壳概述
命令行解释器( CLI) 或shell是代表其用户运行其他程序的程序。shell 反复打印提示，等待用户输入，然后执行请求的操作。您在这个项目中实现的 shell 与您登录到典型 Unix 系统时使用的 shell 相似，但比它简单得多。

用户提供的输入采用一系列命令行的形式。命令行是由空格分隔的 ASCII 单词序列。命令行中的第一个单词要么是内置命令的名称，要么是可执行文件的名称。剩下的词是命令行参数。

Shell 通常会通过运行其他程序来执行请求的操作。但是，某些操作根本无法由其他程序执行。对于这些，shell 提供了一组称为内置命令的命令，并且它以不同的方式处理这些命令。您将在项目稍后实施这些细节。

Shells 还提供其他便利功能。例如，用户可能希望将程序的输出捕获到文件中，以供以后分析。用户可能还希望能够同时运行多个子进程。您将在此项目中实现这两个功能。

在这个项目结束时，您将拥有一个功能齐全（尽管相对简单）的 Unix shell。

排版约定
您应该知道的词汇/术语将以斜体显​​示。

需要强调的地方会以粗体显示。

文件名、代码和终端输出（通常，在处理此项目时您可能希望在终端中看到的任何内容）都将位于teletype中。通常，如果它以unix>开头，那么您应该在常规 shell 中输入这些内容，而以utcsh>开头的内容应该作为项目的输入。

🐚当我们希望指出该项目的工作方式与大多数现实世界的 shell（例如 bash、zsh）的工作方式之间的差异时，将使用 shell 表情符号。

开始与您的合作伙伴
首先与您的合作伙伴交谈，并就您将如何合作达成一致。如果你需要远程工作，你可以在远程协作指南中找到一些想法

根据Git 说明在 UTCS GitLab 服务器上设置存储库

当您本周开始时，请在 本周五晚上提交您对我们小组计划文件中问题的答案。在项目的第二个星期五，我们将要求您提交一份集体反思文件。

开始使用 Shell 项目
我们为这个项目提供了启动代码 。通过从命令行运行以下命令从课程网页获取它：

unix> wget https://www.cs.utexas.edu/%7Eans/classes/cs439/projects/shell_project/shell_project.tar.gz
或在浏览器中下载。




第 0 部分：fork()/wait()
在项目的这个阶段，您将了解将在项目的其余部分中使用的fork()和wait() 系统调用。

第 0.1 部分：阅读
在开始这个项目之前阅读OSTEP 的第 5.4 和 5.6 节 可能会有所帮助。在开始之前，您可能还希望查阅课程资源（例如关于 C 编程和 shell 的使用）。

第 0.2 部分：斐波那契
更新 fib.c 以便如果在命令行上使用某个整数参数 n（其中 n 小于或等于 13）调用，它会递归地计算第 n 个斐波那契数。

为确保您了解fork() / wait()，必须限制您的fib程序的编写方式。完整的规则如下，但总体思路是程序将以递归方式编写，并且每次递归调用必须由新进程进行（即通过调用fork()后跟doFib()）。然后子进程将其结果返回给父进程，父进程一直等到子进程完成。

示例输出：

Unix> 纤维 3
2
Unix> fib 10
55
您的 fib 程序必须符合以下规则：

当给定一个介于 0 和 13（含）之间的参数n时，输出必须是第 n个斐波那契数。
斐波那契数必须递归计算，每个递归调用都发生在一个新进程中。
最终结果必须由原始进程打印。
您可以修改doFib()的主体。
您不得修改doFib()的参数数量或返回值。
只要通过创建子进程完成斐波那契数的计算，您就可以创建辅助方法。
如果给定无效参数，您的fib程序应打印使用消息并退出。
您的程序在运行时不得创建分叉炸弹。对于项目的这一部分，任何分叉炸弹行为都将导致零。
您的输出必须与上面给出的示例完全匹配！
第 1 部分：外壳骨架
在这部分作业中，您将开始构建 shell 的基本框架。在本节结束时，您应该有一个基本的功能性 shell 框架，您将在以后的部分中对其进行扩展和升级。

您的基本外壳将被称为utcsh 1。

注意：第 1 部分和第 2 部分将引导您完成推荐的 shell 实施顺序。您不需要按此顺序实现所有内容，但是，您必须在两个部分中实现所有功能才能获得全部功劳。

请记住在实施任何内容之前阅读整个文档！

第 1.1 部分：阅读
在实现任何东西之前，您应该阅读整个文档以及设计文档模板。是的，阅读量很大。是的，无论如何你都应该这样做（至少浏览文档！）。

不需要额外的外部阅读，但如果您以前没有使用过命令行界面，您可能希望阅读 Ubuntu 的 命令行教程

您可能还会发现阅读strtok、strcmp和execv的联机帮助页会有所帮助，尽管稍后才需要这样做。

第 1.2 部分：REPL
任何 shell 的核心都是 REPL，即读取-评估-打印循环。这是一个重复执行以下三个动作的循环：

从用户（或从用户指定的脚本）读取输入。
评估输入，弄清楚用户想要做什么并去做。
打印与请求的操作相关的任何输出。
在utcsh.c的main()函数中实现 REPL 。在行首打印utcsh>，然后读取用户的输入。

现在，您的 REPL 应该忽略大多数输入。它会响应的唯一命令是内置命令exit，这将导致 shell 通过调用exit(0) 退出。如果在读取输入时到达文件末尾，还应该调用exit(0) 。

要读取输入行，您应该使用getline()。使用man getline了解有关此功能的更多信息。

🐚有趣的一点是，在 C 中，0 为假，非零为真，而在 UNIX 退出代码的世界中，0 表示成功，非零表示失败。事实证明这非常有用，但在您最初学习如何使用 shell 时可能有点难以跟踪。

第 1.3 部分：解析和内置命令
回想一下，命令行由空格分隔的 ASCII 字组成。实现一些方法来拆分命令行，以便您可以恢复这些单词，例如，您应该能够立即知道"path abcd e"的第 4 个单词是"d"。

我们建议您为此使用strtok()。仔细阅读此功能的手册页。众所周知，粗心地使用此功能会导致许多小时的调试。

通过添加错误检查以退出并实现两个新的内置命令，扩展您的 shell 处理内置命令的能力：

exit：您在上一节中实现了此内置功能。现在添加错误处理：将任何参数传递给exit都是错误的。有关如何处理错误的详细信息，请参阅下一节 (1.4)。

cd：cd总是只接受一个参数（任何其他数字都是错误的）。这应该使用用户提供的参数调用chdir()系统调用。如果chdir失败，那也是一个错误。

path：path命令接受零个或多个参数，每个参数由空格分隔。典型的用法可能如下所示：

utcsh> 路径 /bin /usr/bin
该命令将在第 2.1 部分中使用——现在，只需担心能够在不崩溃的情况下分离该命令的参数。

第 1.4 部分：处理错误
上一节我们第一次遇到错误。为了便于实施，您的 shell 只会有一条错误消息：“发生错误”。

每当发生错误时，您的 shell 应该在stderr上打印错误消息 并继续。在第 1.6 部分中描述了您的 shell 应该退出以响应错误的唯一时间。2

下面给出了如何打印错误的示例片段。如果代码段不能满足您的需求，您应该编写自己的函数：

  char emsg[30] = "发生错误\n";
  int nbytes_written = write(STDERR_FILENO, emsg, strlen(emsg));
  如果（nbytes_written ！= strlen（emsg））{
    退出（2）；// 不应该真的发生——如果发生了，错误是不可恢复的
  }
崩溃、段错误或以其他方式破坏 shell 以响应错误的用户输入是不可接受的。您的 shell 必须始终正常退出，即通过调用exit()或从main()返回。

🐚当然，大多数现实世界的 shell 都实现了各种各样的错误消息，以帮助用户找出哪里出了问题。

Part 1.5：执行外部命令
如果给出的命令不是三个内置命令之一，则应将其视为外部可执行程序的路径。

对于这些外部命令，使用课堂上讨论的 fork-and-exec 方法执行程序。这里有一些提示可以帮助您：

对于子进程：子进程必须使用execv()调用来执行给定的命令。您不能调用system()来运行命令。请记住，如果execv()返回，则存在错误（通常由不正确的参数或文件不存在引起）。

对于父进程：父进程应该使用wait()或waitpid()等待子进程。请注意，父母并不关心孩子会发生什么。只要fork()成功，父进程就认为进程启动成功。

🐚典型的 shell 将收集孩子的退出代码，以与程序员交流信息。例如，diff程序的退出代码不仅可以告诉您两个文件是否相同，还可以告诉您它们有何不同。为简单起见，utcsh并不担心这一点。

第 1.6 部分：阅读脚本
有时，不得不一次输入一个命令是非常烦人的。一种常见的解决方案是通过将相关的命令序列放入文件并使用 shell 运行该文件来创建脚本。

实现一个脚本系统：如果使用一个参数调用utcsh ，而不是从stdin读取命令，它假定它的参数是一个文件名，并尝试从该文件而不是从stdin一次读取一个命令。

您可以在示例/目录中找到示例脚本。say_hello.utcsh 是最基本的脚本，由一堆外部命令组成。还有更高级的say_hello_path.utcsh，它依赖于路径功能（您将在 2.1 中实现）。

在脚本模式下操作时还有两个重要的变化：

utcsh >提示不应以脚本模式打印。
如果输入文件无效，或者有多个参数，utcsh 应该打印一条错误消息并以错误代码退出，即调用 exit(1)。这是错误导致utcsh 退出的唯一情况。
请注意，在完成本节之前，您将无法运行自动化测试套件。完成本节后，您可以查看第 4 节以获取有关运行测试的详细信息。

🐚为了向您展示 bash 脚本的外观，我们在示例目录中包含了两个 bash 脚本。一个与 say_hello 脚本做同样的事情，可以使用bash examples/say_hello.bash运行。另一个可以使用bash examples/file_exists.bash <filename>运行，它会告诉你 <filename>是否存在，如果存在，它是常规文件还是目录。

至此，您有一个基本的 shell，可以从脚本和标准输入（键盘输入）运行内置和外部命令——例如，您应该能够运行示例中的say_hello.utcsh脚本 目录。

现在可能是进行 git 提交的好时机，如果您还没有这样做的话！

第 2 部分：高级 Shell 功能
第 2.1 部分：路径
当您实现外部程序执行时，您假设第 0 个参数是可执行文件的路径。不幸的是，这对用户来说很烦人，因为没有人愿意在每次运行ls命令时都输入/usr/local/bin/ls 。

解决方案是PATH：一组用户指定的目录，用于搜索外部程序。当 shell 收到一个它无法识别的命令时，它会在它的PATH中寻找这个程序。

请注意，对于本文档的其余部分，“路径”将指的是一个带有斜线的字符串，用于定位文件，而PATH将用于指用于搜索二进制文件的路径列表。3

如果给你的程序不是绝对路径，即从/开始的路径，你应该在PATH的每个目录中搜索你的程序。例如，如果您的PATH是"/bin" "/usr/bin"，您将搜索 /bin/ls和/usr/bin/ls，执行您找到的第一个（如果都不存在则返回错误）。您可以使用我们在框架代码中提供的函数检查该文件是否存在并且是否可执行。如果该文件不存在，或者它不可执行，这是一个错误。

用户可以使用path命令设置PATH 。路径的每个参数 对应于 shell 的PATH中的一个条目。path命令完全覆盖现有的PATH ——它不附加条目。如果 PATH 因为用户执行了不带参数的路径命令而为空，则 utcsh无法执行任何外部程序，除非提供程序的完整路径。

框架代码中已经为您提供了一个PATH变量，称为shell_paths。您可以直接操作此变量，也可以使用util.c / util.h中的辅助函数。

🐚真正的 shell 还允许您指定程序的相对路径，例如，您可以键入bin/myprog以运行相对于当前工作目录的程序。对于 utcsh，您无需担心这一点：程序名称可以是绝对路径，也可以是要在shell_paths中搜索的程序名称。

提醒：shell 本身并没有实现ls或任何其他程序——它只是在路径中查找它们并执行它们。

第 2.2 部分：重定向
很多时候，shell 用户更喜欢将程序的输出发送到文件而不是屏幕。通常，shell 通过>字符来提供这个很好的特性。这正式称为输出重定向。你的 shell 应该包含这个特性。

例如，如果用户键入ls -al /tmp > output，则不应在屏幕上打印任何内容。相反，程序的标准输出和标准错误应该重新路由到文件输出。

如果输出文件已经存在，您应该覆盖并截断它。查看man 2 open中的标志以了解如何执行此操作。

以下是有关重定向运算符的一些规则：

命令中的多个重定向是错误的，例如ls > file1 > file2。
没有相应命令的重定向是错误的，例如> file1。
没有相应文件的重定向是错误的，例如ls >
重定向周围总会有空格，例如ls>file1请求执行名为ls>file1的文件的命令，而不是重定向。
您无需担心内置命令的重定向，例如，当您键入path /bin > file时，我们不会测试会发生什么。
🐚真正的shell 通常允许多个重定向，并分别重定向stdout和 stderr，并允许您将它们相互重定向，例如您可以将stdout 定向到stderr。

第 2.3 部分：并发命令
您的 shell 将允许用户启动并发命令。请记住：当两件事情并发时，无论它们实际上是否同时运行（逻辑并行），它们似乎都是同时执行的。在 UTCSH 中，这是通过 & 运算符完成的：

utcsh> cmd1 & cmd2 & cmd3 args1
而不是运行cmd1，等待它完成，然后运行​​cmd2，你的 shell 应该运行cmd1，cmd2和cmd3（无论传递了什么参数） ，然后等待它们中的任何一个完成。

然后，一旦所有进程都已启动，您必须使用wait()或waitpid() 确保所有进程都已完成，然后再继续。

每个单独的命令可以选择有自己的重定向，例如

utcsh> cmd1 > file1 & cmd2 arg1 arg2 > file2 & cmd3 > file3
与重定向运算符不同，与号运算符周围可能没有空格。例如cmd1 arg1&cmd2 > file2是一个有效的命令行，并请求执行两个命令。此外，与号两侧的部分或全部命令可能为空白。这意味着，例如， &&&&&&&是一个有效的命令行。

在处理这些命令时，需要考虑许多特殊情况。在这样做时，您可以假设以下内容：

如果命令行有多个并发命令，这些命令都是外部的，则适用当前规范。
如果一个命令行有多个内置的并发命令，shell 应该从左到右顺序执行它们。
您可能会假设我们不会测试具有混合并发外部/内部内置命令的命令行。如果发生这种情况，您的 shell 不应该崩溃，否则，对于它必须做什么没有任何要求。
🐚在大多数类似 bash 的 shell 中，&实际上附加到命令的末尾以指示它在后台运行。如果您想了解更多信息，可以搜索“Bash Job Control”，但不要尝试在实际的 shell 中使用此语法来并行运行作业，否则可能会发生奇怪的事情！
  
  要运行完整的测试套件，请运行make check。
要运行单个测试，请运行make testcase id=#，例如make testcase id=15。
要获取测试的描述，请运行make describe id=#。如果您不确定测试做什么或想要获取命令自己运行它（例如在调试器下运行它），这可能很有用
  
  make debug
